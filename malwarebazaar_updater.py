from utils.paths import get_resource_path
import os

from utils import extract_archive
import requests
from requests.exceptions import RequestException
import logging
import os
import json
from typing import Optional, Dict, Any
import shutil
import time

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MalwareBazaarUpdater:
    """
    Class to handle updating Malware Bazaar signatures.
    """
    
    def __init__(self, api_key: Optional[str] = None, 
                 signatures_path: str = "signatures/malware_bazaar",
                 api_url: str = "https://mb-api.abuse.ch/api/v1/"):
        """
        Initialize the Malware Bazaar updater.
        
        Args:
            api_key: Optional API key for Malware Bazaar
            signatures_path: Path to store signature files
            api_url: Malware Bazaar API URL
        """
        self.api_key = api_key
        self.signatures_path = signatures_path
        self.api_url = api_url
        
        # Create signatures directory if it doesn't exist
        os.makedirs(self.signatures_path, exist_ok=True)
    
    def _make_api_request(self, query_type: str, params: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Make a request to the Malware Bazaar API with retry mechanism.
        
        Args:
            query_type: Type of query to make
            params: Parameters for the query
            
        Returns:
            API response as dictionary or None if request failed
        """
        headers = {}
        if self.api_key:
            headers["API-KEY"] = self.api_key
            
        data = {"query": query_type, **params}
        
        for attempt in range(MAX_RETRIES):
            try:
                logger.info(f"Attempting API request (attempt {attempt + 1}/{MAX_RETRIES})")
                response = requests.post(self.api_url, headers=headers, data=data, timeout=30)
                
                if response.status_code == 200:
                    logger.info("API request successful")
                    return response.json()
                else:
                    logger.warning(f"API request failed with status code: {response.status_code}")
                    logger.debug(f"Response content: {response.text}")
                    
                if attempt < MAX_RETRIES - 1:
                    logger.info(f"Retrying in {RETRY_DELAY} seconds...")
                    time.sleep(RETRY_DELAY)
                
            except RequestException as e:
                logger.error(f"Error making API request: {str(e)}")
                if attempt < MAX_RETRIES - 1:
                    logger.info(f"Retrying in {RETRY_DELAY} seconds...")
                    time.sleep(RETRY_DELAY)
        
        logger.error("All API request attempts failed")
        return None
    
    def _process_signature(self, signature_data: Optional[Dict[str, Any]]) -> Optional[str]:
        """
        Process a signature from the API response.
        
        Args:
            signature_data: Signature data from API
            
        Returns:
            Processed signature string or None if processing failed
        """
        if not signature_data:
            logger.warning("Signature data is None")
            return None
        
        try:
            # Debug log to inspect the full data structure
            logger.debug(f"Processing signature data: {json.dumps(signature_data, indent=4)}")

            # Extract signature content
            signature_content = signature_data.get("signature")

            # Validate signature_content before modifying
            if signature_content is None:
                logger.warning(f"Missing 'signature' in signature data: {json.dumps(signature_data, indent=4)}")
                return None
            
            if not isinstance(signature_content, str):
                logger.warning(f"'signature' is not a string: {type(signature_content)} - Value: {signature_content}")
                return None

            # Process the signature content
            processed_content = signature_content.strip()
            
            # Add YARA rule structure if not present
            if not processed_content.startswith("rule "):
                rule_name = signature_data.get("signature_name", "malware_bazaar_rule")
                sha256_hash = signature_data.get("sha256_hash", "")
                description = signature_data.get("description", "Malware Bazaar Signature")
                
                processed_content = f"""
rule {rule_name} {{
    meta:
        description = "{description}"
        sha256 = "{sha256_hash}"
    strings:
        $s = "{processed_content}"
    condition:
        $s
}}
"""
            return processed_content
        
        except Exception as e:
            logger.error(f"Error processing signature: {str(e)}")
            return None

    def update_signatures(self) -> bool:
        """
        Update Malware Bazaar signatures.
        
        Returns:
            True if update was successful, False otherwise
        """
        try:
            logger.info("Updating Malware Bazaar signatures...")
            
            # Get recent signatures - adjust parameters based on actual API
            response = self._make_api_request("get_recent", {"limit": 100})
            
            if not response:
                logger.warning("No response received from Malware Bazaar API")
                return False
            
            signatures = response.get("data")
            if not signatures:
                logger.warning("No signatures found in API response")
                return False
            
            success_count = 0
            for idx, signature_data in enumerate(signatures):
                # Get signature ID or use index as fallback
                signature_id = signature_data.get("sha256_hash", f"signature_{idx}")
                
                # Process the signature
                processed_signature = self._process_signature(signature_data)
                
                # Skip if processing failed
                if processed_signature is None:
                    logger.warning(f"Failed to process signature {signature_id}")
                    continue
                    
                # Save the signature to a file
                signature_file = os.path.join(self.signatures_path, f"{signature_id}.yar")
                with open(get_resource_path(os.path.join(signature_file)), "w") as f:
                    f.write(processed_signature)
                    
                success_count += 1
            
            logger.info(f"Successfully updated {success_count} Malware Bazaar signatures")
            return success_count > 0
            
        except Exception as e:
            logger.error(f"Error updating Malware Bazaar signatures: {str(e)}")
            return False

# Function to use the updater
def update_local_signatures(api_key: Optional[str] = None) -> bool:
    """
    Update Malware Bazaar signatures.
    
    Args:
        api_key: Optional API key for Malware Bazaar
        
    Returns:
        True if update was successful, False otherwise
    """
    try:
        updater = MalwareBazaarUpdater(api_key=api_key)
        success = updater.update_signatures()
        
        if not success:
            logger.warning("Malware Bazaar signatures update failed")
            
        return success
        
    except Exception as e:
        logger.error(f"Error updating Malware Bazaar signatures: {str(e)}")
        return False

# Example usage
if __name__ == "__main__":
    update_local_signatures()

MAX_RETRIES = 3
RETRY_DELAY = 5  # seconds